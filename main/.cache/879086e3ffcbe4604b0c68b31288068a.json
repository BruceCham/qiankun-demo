{"dependencies":[{"name":"@babel/runtime/helpers/interopRequireDefault","loc":{"line":3,"column":37}},{"name":"lodash/concat","loc":{"line":10,"column":46}},{"name":"lodash/mergeWith","loc":{"line":12,"column":49}},{"name":"@babel/runtime/helpers/typeof","loc":{"line":14,"column":46}},{"name":"tslib","loc":{"line":16,"column":21}},{"name":"import-html-entry","loc":{"line":18,"column":31}},{"name":"./addons","loc":{"line":20,"column":45}},{"name":"./globalState","loc":{"line":22,"column":27}},{"name":"./sandbox","loc":{"line":24,"column":23}},{"name":"./utils","loc":{"line":26,"column":21}}],"generated":{"js":"\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadApp = loadApp;\n\nvar _concat2 = _interopRequireDefault(require(\"lodash/concat\"));\n\nvar _mergeWith2 = _interopRequireDefault(require(\"lodash/mergeWith\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _tslib = require(\"tslib\");\n\nvar _importHtmlEntry = require(\"import-html-entry\");\n\nvar _addons = _interopRequireDefault(require(\"./addons\"));\n\nvar _globalState = require(\"./globalState\");\n\nvar _sandbox = require(\"./sandbox\");\n\nvar _utils = require(\"./utils\");\n\n/**\n * @author Kuitos\n * @since 2020-04-01\n */\nfunction assertElementExist(element, msg) {\n  if (!element) {\n    if (msg) {\n      throw new Error(msg);\n    }\n\n    throw new Error('[qiankun] element not existed!');\n  }\n}\n\nfunction toArray(array) {\n  return Array.isArray(array) ? array : [array];\n}\n\nfunction execHooksChain(hooks, app) {\n  if (hooks.length) {\n    return hooks.reduce(function (chain, hook) {\n      return chain.then(function () {\n        return hook(app);\n      });\n    }, Promise.resolve());\n  }\n\n  return Promise.resolve();\n}\n\nfunction validateSingularMode(validate, app) {\n  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n    return (0, _tslib.__generator)(this, function (_a) {\n      return [2\n      /*return*/\n      , typeof validate === 'function' ? validate(app) : !!validate];\n    });\n  });\n}\n\nfunction createElement(appContent, strictStyleIsolation) {\n  var containerElement = document.createElement('div');\n  containerElement.innerHTML = appContent; // appContent always wrapped with a singular div\n\n  var appElement = containerElement.firstChild;\n\n  if (strictStyleIsolation) {\n    var innerHTML = appElement.innerHTML;\n    appElement.innerHTML = '';\n    var shadow = appElement.attachShadow({\n      mode: 'open'\n    });\n    shadow.innerHTML = innerHTML;\n  }\n\n  return appElement;\n}\n/** generate app wrapper dom getter */\n\nfunction getAppWrapperGetter(appName, appInstanceId, useLegacyRender, strictStyleIsolation, elementGetter) {\n  return function () {\n    if (useLegacyRender) {\n      if (strictStyleIsolation) throw new Error('[qiankun]: strictStyleIsolation can not be used with legacy render!');\n      var appWrapper = document.getElementById((0, _utils.getWrapperId)(appInstanceId));\n      assertElementExist(appWrapper, \"[qiankun] Wrapper element for \" + appName + \" with instance \" + appInstanceId + \" is not existed!\");\n      return appWrapper;\n    }\n\n    var element = elementGetter();\n    assertElementExist(element, \"[qiankun] Wrapper element for \" + appName + \" with instance \" + appInstanceId + \" is not existed!\");\n\n    if (strictStyleIsolation) {\n      return element.shadowRoot;\n    }\n\n    return element;\n  };\n}\n\nvar rawAppendChild = HTMLElement.prototype.appendChild;\nvar rawRemoveChild = HTMLElement.prototype.removeChild;\n/**\n * Get the render function\n * If the legacy render function is provide, used as it, otherwise we will insert the app element to target container by qiankun\n * @param appName\n * @param appContent\n * @param container\n * @param legacyRender\n */\n\nfunction getRender(appName, appContent, container, legacyRender) {\n  var render = function render(_a, phase) {\n    var element = _a.element,\n        loading = _a.loading;\n\n    if (legacyRender) {\n      if (undefined === 'development') {\n        console.warn('[qiankun] Custom rendering function is deprecated, you can use the container element setting instead!');\n      }\n\n      return legacyRender({\n        loading: loading,\n        appContent: element ? appContent : ''\n      });\n    }\n\n    var containerElement = typeof container === 'string' ? document.querySelector(container) : container; // The container might have be removed after micro app unmounted.\n    // Such as the micro app unmount lifecycle called by a react componentWillUnmount lifecycle, after micro app unmounted, the react component might also be removed\n\n    if (phase !== 'unmounted') {\n      var errorMsg = function () {\n        switch (phase) {\n          case 'loading':\n          case 'mounting':\n            return \"[qiankun] Target container with \" + container + \" not existed while \" + appName + \" \" + phase + \"!\";\n\n          case 'mounted':\n            return \"[qiankun] Target container with \" + container + \" not existed after \" + appName + \" \" + phase + \"!\";\n\n          default:\n            return \"[qiankun] Target container with \" + container + \" not existed while \" + appName + \" rendering!\";\n        }\n      }();\n\n      assertElementExist(containerElement, errorMsg);\n    }\n\n    if (containerElement && !containerElement.contains(element)) {\n      // clear the container\n      while (containerElement.firstChild) {\n        rawRemoveChild.call(containerElement, containerElement.firstChild);\n      } // append the element to container if it exist\n\n\n      if (element) {\n        rawAppendChild.call(containerElement, element);\n      }\n    }\n\n    return undefined;\n  };\n\n  return render;\n}\n\nfunction getLifecyclesFromExports(scriptExports, appName, global) {\n  if ((0, _utils.validateExportLifecycle)(scriptExports)) {\n    return scriptExports;\n  }\n\n  if (undefined === 'development') {\n    console.warn(\"[qiankun] lifecycle not found from \" + appName + \" entry exports, fallback to get from window['\" + appName + \"']\");\n  } // fallback to global variable who named with ${appName} while module exports not found\n\n\n  var globalVariableExports = global[appName];\n\n  if ((0, _utils.validateExportLifecycle)(globalVariableExports)) {\n    return globalVariableExports;\n  }\n\n  throw new Error(\"[qiankun] You need to export lifecycle functions in \" + appName + \" entry\");\n}\n\nvar appInstanceCounts = {};\nvar prevAppUnmountedDeferred;\n\nfunction loadApp(app, configuration, lifeCycles) {\n  if (configuration === void 0) {\n    configuration = {};\n  }\n\n  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n    var entry, appName, _a, singular, _b, sandbox, importEntryOpts, _c, template, execScripts, assetPublicPath, appInstanceId, strictStyleIsolation, appContent, element, container, legacyRender, render, containerGetter, global, mountSandbox, unmountSandbox, sandboxInstance, _d, _e, beforeUnmount, _f, afterUnmount, _g, afterMount, _h, beforeMount, _j, beforeLoad, scriptExports, _k, bootstrap, mount, unmount, update, _l, onGlobalStateChange, setGlobalState, offGlobalStateChange, parcelConfig;\n\n    var _this = this;\n\n    return (0, _tslib.__generator)(this, function (_m) {\n      switch (_m.label) {\n        case 0:\n          entry = app.entry, appName = app.name;\n          _a = configuration.singular, singular = _a === void 0 ? false : _a, _b = configuration.sandbox, sandbox = _b === void 0 ? true : _b, importEntryOpts = (0, _tslib.__rest)(configuration, [\"singular\", \"sandbox\"]);\n          return [4\n          /*yield*/\n          , (0, _importHtmlEntry.importEntry)(entry, importEntryOpts)];\n\n        case 1:\n          _c = _m.sent(), template = _c.template, execScripts = _c.execScripts, assetPublicPath = _c.assetPublicPath;\n          return [4\n          /*yield*/\n          , validateSingularMode(singular, app)];\n\n        case 2:\n          if (!_m.sent()) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , prevAppUnmountedDeferred && prevAppUnmountedDeferred.promise];\n\n        case 3:\n          _m.sent();\n\n          _m.label = 4;\n\n        case 4:\n          appInstanceId = appName + \"_\" + (appInstanceCounts.hasOwnProperty(appName) ? appInstanceCounts[appName] += 1 : appInstanceCounts[appName] = 0);\n          strictStyleIsolation = (0, _typeof2.default)(sandbox) === 'object' && !!sandbox.strictStyleIsolation;\n          appContent = (0, _utils.getDefaultTplWrapper)(appInstanceId)(template);\n          element = createElement(appContent, strictStyleIsolation);\n          container = 'container' in app ? app.container : undefined;\n          legacyRender = 'render' in app ? app.render : undefined;\n          render = getRender(appName, appContent, container, legacyRender); // 第一次加载设置应用可见区域 dom 结构\n          // 确保每次应用加载前容器 dom 结构已经设置完毕\n\n          render({\n            element: element,\n            loading: true\n          }, 'loading');\n          containerGetter = getAppWrapperGetter(appName, appInstanceId, !!legacyRender, strictStyleIsolation, function () {\n            return element;\n          });\n          global = window;\n\n          mountSandbox = function mountSandbox() {\n            return Promise.resolve();\n          };\n\n          unmountSandbox = function unmountSandbox() {\n            return Promise.resolve();\n          };\n\n          if (sandbox) {\n            sandboxInstance = (0, _sandbox.createSandbox)(appName, containerGetter, Boolean(singular)); // 用沙箱的代理对象作为接下来使用的全局对象\n\n            global = sandboxInstance.proxy;\n            mountSandbox = sandboxInstance.mount;\n            unmountSandbox = sandboxInstance.unmount;\n          }\n\n          _d = (0, _mergeWith2.default)({}, (0, _addons.default)(global, assetPublicPath), lifeCycles, function (v1, v2) {\n            return (0, _concat2.default)(v1 !== null && v1 !== void 0 ? v1 : [], v2 !== null && v2 !== void 0 ? v2 : []);\n          }), _e = _d.beforeUnmount, beforeUnmount = _e === void 0 ? [] : _e, _f = _d.afterUnmount, afterUnmount = _f === void 0 ? [] : _f, _g = _d.afterMount, afterMount = _g === void 0 ? [] : _g, _h = _d.beforeMount, beforeMount = _h === void 0 ? [] : _h, _j = _d.beforeLoad, beforeLoad = _j === void 0 ? [] : _j;\n          return [4\n          /*yield*/\n          , execHooksChain(toArray(beforeLoad), app)];\n\n        case 5:\n          _m.sent();\n\n          return [4\n          /*yield*/\n          , execScripts(global, !singular)];\n\n        case 6:\n          scriptExports = _m.sent();\n          _k = getLifecyclesFromExports(scriptExports, appName, global), bootstrap = _k.bootstrap, mount = _k.mount, unmount = _k.unmount, update = _k.update;\n          _l = (0, _globalState.getMicroAppStateActions)(appInstanceId), onGlobalStateChange = _l.onGlobalStateChange, setGlobalState = _l.setGlobalState, offGlobalStateChange = _l.offGlobalStateChange;\n          parcelConfig = {\n            name: appInstanceId,\n            bootstrap: bootstrap,\n            mount: [function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , validateSingularMode(singular, app)];\n\n                    case 1:\n                      if (_a.sent() && prevAppUnmountedDeferred) {\n                        return [2\n                        /*return*/\n                        , prevAppUnmountedDeferred.promise];\n                      }\n\n                      return [2\n                      /*return*/\n                      , undefined];\n                  }\n                });\n              });\n            }, // 添加 mount hook, 确保每次应用加载前容器 dom 结构已经设置完毕\n            function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  // element would be destroyed after unmounted, we need to recreate it if it not exist\n                  element = element || createElement(appContent, strictStyleIsolation);\n                  render({\n                    element: element,\n                    loading: true\n                  }, 'mounting');\n                  return [2\n                  /*return*/\n                  ];\n                });\n              });\n            }, // exec the chain after rendering to keep the behavior with beforeLoad\n            function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , execHooksChain(toArray(beforeMount), app)];\n                });\n              });\n            }, mountSandbox, function (props) {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , mount((0, _tslib.__assign)((0, _tslib.__assign)({}, props), {\n                    container: containerGetter(),\n                    setGlobalState: setGlobalState,\n                    onGlobalStateChange: onGlobalStateChange\n                  }))];\n                });\n              });\n            }, // 应用 mount 完成后结束 loading\n            function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , render({\n                    element: element,\n                    loading: false\n                  }, 'mounted')];\n                });\n              });\n            }, function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , execHooksChain(toArray(afterMount), app)];\n                });\n              });\n            }, // initialize the unmount defer after app mounted and resolve the defer after it unmounted\n            function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , validateSingularMode(singular, app)];\n\n                    case 1:\n                      if (_a.sent()) {\n                        prevAppUnmountedDeferred = new _utils.Deferred();\n                      }\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }],\n            unmount: [function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , execHooksChain(toArray(beforeUnmount), app)];\n                });\n              });\n            }, function (props) {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , unmount((0, _tslib.__assign)((0, _tslib.__assign)({}, props), {\n                    container: containerGetter()\n                  }))];\n                });\n              });\n            }, unmountSandbox, function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , execHooksChain(toArray(afterUnmount), app)];\n                });\n              });\n            }, function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  render({\n                    element: null,\n                    loading: false\n                  }, 'unmounted');\n                  offGlobalStateChange(appInstanceId); // for gc\n\n                  element = null;\n                  return [2\n                  /*return*/\n                  ];\n                });\n              });\n            }, function () {\n              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n                return (0, _tslib.__generator)(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , validateSingularMode(singular, app)];\n\n                    case 1:\n                      if (_a.sent() && prevAppUnmountedDeferred) {\n                        prevAppUnmountedDeferred.resolve();\n                      }\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }]\n          };\n\n          if (typeof update === 'function') {\n            parcelConfig.update = update;\n          }\n\n          return [2\n          /*return*/\n          , parcelConfig];\n      }\n    });\n  });\n}"},"hash":"63dddfd07a2a4520385ede6ed818da14"}