{"dependencies":[{"name":"tslib","loc":{"line":10,"column":21}},{"name":"../utils","loc":{"line":12,"column":21}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTargetValue = getTargetValue;\nexports.getProxyPropertyGetter = getProxyPropertyGetter;\nexports.setProxyPropertyGetter = setProxyPropertyGetter;\n\nvar _tslib = require(\"tslib\");\n\nvar _utils = require(\"../utils\");\n\n/**\n * @author Kuitos\n * @since 2020-04-13\n */\nvar boundValueSymbol = Symbol('bound value');\n\nfunction getTargetValue(target, value) {\n  /*\n    仅绑定 !isConstructable && isCallable 的函数对象，如 window.console、window.atob 这类。目前没有完美的检测方式，这里通过 prototype 中是否还有可枚举的拓展方法的方式来判断\n    @warning 这里不要随意替换成别的判断方式，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常）\n   */\n  if (typeof value === 'function' && !(0, _utils.isConstructable)(value)) {\n    if (value[boundValueSymbol]) {\n      return value[boundValueSymbol];\n    }\n\n    var boundValue_1 = value.bind(target); // some callable function has custom fields, we need to copy the enumerable props to boundValue. such as moment function.\n\n    Object.keys(value).forEach(function (key) {\n      return boundValue_1[key] = value[key];\n    });\n    Object.defineProperty(value, boundValueSymbol, {\n      enumerable: false,\n      value: boundValue_1\n    });\n    return boundValue_1;\n  }\n\n  return value;\n}\n\nvar proxyGetterMap = new Map();\n\nfunction getProxyPropertyGetter(proxy, property) {\n  var getters = proxyGetterMap.get(proxy) || {};\n  return getters[property];\n}\n\nfunction setProxyPropertyGetter(proxy, property, getter) {\n  var _a;\n\n  var prevGetters = proxyGetterMap.get(proxy) || {};\n  proxyGetterMap.set(proxy, (0, _tslib.__assign)((0, _tslib.__assign)({}, prevGetters), (_a = {}, _a[property] = getter, _a)));\n}"},"hash":"c4573bd16ddf1e5f8852b1d0b2c861f2"}